import ida_bytes
import ida_idaapi
import idautils
import ida_xref


class StrDecryptor:
    '''
    String decryptor for carbanak backdoor.
    sample: f6f6363d0ba887a96b2ca28630d4de5455cec9183b186ef965d3ec564f655997
    '''

    def __init__(self):
        # find constants
        const_0,const_1,const_2 = self.find_constants()
        # prepare keystream
        prep_key = self.prep_key_stream(const_1,const_2,const_1,const_0)
        self.keystream = self.map_keystream(prep_key)[:0x80]

    def prep_key_stream(self,k,x,y,z):
        keystream = [x for x in range(256)]
        count = k % 0x3E8 + 128
        keystream,y = self.swap_blob(keystream,x,y,z,1,31,count)
        keystream,y = self.swap_blob(keystream,x,y,z,32,127,count)
        keystream,y = self.swap_blob(keystream,x,y,z,128,255,count)
        return keystream

    @staticmethod
    def swap_blob(keystream,x,y,z,start,end,count):
        length = end - start + 1
        for _ in range(count):
            v7 = (x + y * z) & 0xffff
            y = (x + v7 * z) & 0xffff
            ind0 = start + v7 % length
            swap0 = keystream[ind0]
            ind1 = start + y % length
            swap1 = keystream[ind1]
            keystream[ind0] = swap1
            keystream[ind1] = swap0

        return keystream,y

    def map_keystream(self,keystream):
        res_keystream = [0]*256
        for k in range(256):
            res_keystream[keystream[k]] = k
        return res_keystream



    def decrypt_str(self,input_str:bytes):
        # assert len(input_str) % 4 == 0
        blob_size = int((len(input_str)-4) / 4)
        if(blob_size <= 0):
            return
        assert blob_size > 0
        # print(f"blob size : {blob_size}")
        final_str = ""

        for b in range(4):
            sub_x = input_str[b*(blob_size+1)]-ord('a')
            # print(f"Blob : {b} sub_x = {hex(sub_x)}")
            for i in range(blob_size):
                v12 = input_str[i+(b*(blob_size+1)+1)]
                if v12 >= 32:
                    v13 = 127
                    v14 = 32
                else:
                    v13 = 31
                    v14 = 1
                r = self.keystream[v12]-sub_x
                if r < v14:
                    r = v13-v14+r
                final_str += chr(r)

        # Add leftover bytes
        up_limit = len(input_str)
        low_limit = len(input_str) - (len(input_str)%4)
        for i in range(low_limit,up_limit):
            v12 = input_str[i]
            if v12 >= 32:
                v13 = 127
                v14 = 32
            else:
                v13 = 31
                v14 = 1
            r = self.keystream[v12]-sub_x
            if r < v14:
                r = v13-v14+r
            final_str += chr(r)
        return final_str

    @staticmethod
    def find_pattern(pattern):
        ea = ida_bytes.find_bytes(pattern,0)
        ea_next = ida_bytes.find_bytes(pattern,ea+1)
        if ea_next != ida_idaapi.BADADDR:
            raise ValueError("Multiple patterns found")
        return ea

    @staticmethod
    def add_cmt(ea,str_dec):
        # adds comment to disasembly view
        idaapi.set_cmt(ea,str_dec,1)
        try:
            cfunc = idaapi.decompile(ea)
            if cfunc:
                tl = idaapi.treeloc_t()
                tl.ea = ea
                tl.itp = idaapi.ITP_SEMI
                cfunc.set_user_cmt(tl,f"{str_dec}")
                cfunc.save_user_cmts()
                idaapi.refresh_idaview_anyway()
        except Exception as e:
                print(f"error at setting cmt to decompile view : {e}")
                pass


    @staticmethod
    def get_u16_at(ea):
        return int.from_bytes(ida_bytes.get_bytes(ea,2),byteorder='little')

    def find_constants(self):
        # .text:0000000140001E8E 48 81 EC C0 01 00 00                    sub     rsp, 1C0h
        # .text:0000000140001E95 0F B7 05 18 D5 01 00                    movzx   eax, cs:const_5921             << const_0
        # .text:0000000140001E9C 0F B7 1D 0F D5 01 00                    movzx   ebx, cs:const_3D07             << const_1
        # .text:0000000140001EA3 83 25 8A DD 01 00 00                    and     cs:dword_14001FC34, 0
        # .text:0000000140001EAA 89 05 98 DD 01 00                       mov     cs:init_5921, eax
        # .text:0000000140001EB0 0F B7 05 FF D4 01 00                    movzx   eax, cs:const_54E9             << const_2
        # .text:0000000140001EB7 89 1D 97 DE 01 00                       mov     cs:init_3D07, ebx
        # .text:0000000140001EBD 89 05 89 DD 01 00                       mov     cs:init_54E9, eax
        # .text:0000000140001EC3 33 C0                                   xor     eax, eax
        # .text:0000000140001EC5 48 8D 4D C0                             lea     rcx, [rbp+0D0h+var_110]
        # .text:0000000140001EC9
        # .text:0000000140001EC9                         loc_140001EC9:                          ; CODE XREF: sub_140001E78+5D↓j
        # .text:0000000140001EC9 88 01                                   mov     [rcx], al
        # .text:0000000140001ECB FF C0                                   inc     eax
        # .text:0000000140001ECD 48 FF C1                                inc     rcx
        # .text:0000000140001ED0 3D 00 01 00 00                          cmp     eax, 100h
        # .text:0000000140001ED5 7C F2                                   jl      short loc_140001EC9
        # .text:0000000140001ED7 41 BE 80 00 00 00                       mov     r14d, 80h                      << Pattern finds this offset
        # .text:0000000140001EDD B8 D3 4D 62 10                          mov     eax, 10624DD3h
        # .text:0000000140001EE2 48 8D 4D C0                             lea     rcx, [rbp+0D0h+var_110]
        pattern = b"\x41\xBE\x80\x00\x00\x00\xB8\xD3\x4D\x62\x10\x48\x8D\x4D\xC0"
        ea = self.find_pattern(pattern)
        print("Pattern found at: 0x%x" % ea)
        # Walk upwards to find the constants
        p = ea; [p := idc.prev_head(p) for _ in range(14)]
        ea_1E95 = p
        # Get right side operand
        const_0 = self.get_u16_at(idc.get_operand_value(ea_1E95,1))
        print(f"const_0: {hex(const_0)} at {hex(ea_1E95)}")
        ea_1E9C = idc.next_head(ea_1E95)
        const_1 = self.get_u16_at(idc.get_operand_value(ea_1E9C,1))
        print(f"const_1: {hex(const_1)} at {hex(ea_1E9C)}")
        [ea_1E9C := idc.next_head(ea_1E9C) for i in range(3)]
        const_2 = self.get_u16_at(idc.get_operand_value(ea_1E9C,1))
        print(f"const_2: {hex(const_2)} at {hex(ea_1E9C)}")
        return const_0,const_1,const_2


    def find_str_dec_function(self):       

        # .text:0000000140001ED7 41 BE 80 00 00 00                       mov     r14d, 80h                      << Pattern finds here
        # .text:0000000140001EDD B8 D3 4D 62 10                          mov     eax, 10624DD3h
        # .text:0000000140001EE2 48 8D 4D C0                             lea     rcx, [rbp+0D0h+var_110]
        # .text:0000000140001EE6 45 8D 46 9F                             lea     r8d, [r14-61h]
        # .text:0000000140001EEA F7 E3                                   mul     ebx
        # .text:0000000140001EEC C1 EA 06                                shr     edx, 6
        # .text:0000000140001EEF 69 D2 E8 03 00 00                       imul    edx, 3E8h
        # .text:0000000140001EF5 2B DA                                   sub     ebx, edx
        # .text:0000000140001EF7 41 8D 56 81                             lea     edx, [r14-7Fh]
        # .text:0000000140001EFB 41 03 DE                                add     ebx, r14d
        # .text:0000000140001EFE 44 8B CB                                mov     r9d, ebx
        # .text:0000000140001F01 E8 96 FB FF FF                          call    mw_crypt_ctx_init
        # .text:0000000140001F06 41 8D 56 A0                             lea     edx, [r14-60h]
        # .text:0000000140001F0A 45 8D 46 FF                             lea     r8d, [r14-1]
        # .text:0000000140001F0E 48 8D 4D C0                             lea     rcx, [rbp+0D0h+var_110]
        # .text:0000000140001F12 44 8B CB                                mov     r9d, ebx
        # .text:0000000140001F15 E8 82 FB FF FF                          call    mw_crypt_ctx_init
        # .text:0000000140001F1A 45 8D 46 7F                             lea     r8d, [r14+7Fh]
        # .text:0000000140001F1E 48 8D 4D C0                             lea     rcx, [rbp+0D0h+var_110]
        # .text:0000000140001F22 44 8B CB                                mov     r9d, ebx
        # .text:0000000140001F25 41 8B D6                                mov     edx, r14d
        # .text:0000000140001F28 E8 6F FB FF FF                          call    mw_crypt_ctx_init
        # .text:0000000140001F2D 33 C9                                   xor     ecx, ecx
        # .text:0000000140001F2F 48 8D 55 C0                             lea     rdx, [rbp+0D0h+var_110]
        # .text:0000000140001F33
        # .text:0000000140001F33                         loc_140001F33:                          ; CODE XREF: sub_140001E78+D5↓j
        # .text:0000000140001F33 48 0F BE 02                             movsx   rax, byte ptr [rdx]
        # .text:0000000140001F37 4C 8D 05 A2 DF 01 00                    lea     r8, mw_crypt_keystream
        pattern = b"\x41\xBE\x80\x00\x00\x00\xB8\xD3\x4D\x62\x10\x48\x8D\x4D\xC0"
        ea = self.find_pattern(pattern)
        print("Pattern found at: 0x%x" % ea)
        # Walk upwards to find the constants
        p = ea; [p := idc.next_head(p) for _ in range(25)]
        # Get rightside operand
        p_keystream = idc.get_operand_value(p,1)
        print(f"Keystream: {hex(p_keystream)} at {hex(p)}")
        # Find xref to this address
        xrefs = [x.frm for x in idautils.XrefsTo(p_keystream,ida_xref.XREF_DATA)]
        # remove xref that equals to p
        xrefs = [x for x in xrefs if x != p]
        if len(xrefs) != 1:
            print(f"Xrefs to keystream: {xrefs}")
            raise ValueError("More than one xref found")
        str_dec_ea = xrefs[0]
        str_dec_func = ida_funcs.get_func(str_dec_ea)
        print(f"String decryptor function: {str_dec_func.start_ea}")
        return str_dec_func.start_ea
    
    def find_func_xrefs_for_decryption(self):
        """
        There are 2 ways malware decrypts strings:
        1. Decrypt strings by just using the string decryptor function
        2. Using caller function to call string decryptor function

        For the first case, we can find all xrefs to the string decryptor function and get string offset from
        "lea rcx, pStr" instruction. Since string is first argument

        For the second case, we can find all xrefs to the caller of string decryptor function and get string offset
        from "lea rdx, pStr" instruction. Since string is second argument
        """


        dec_func_ea = self.find_str_dec_function()
        # Find all xrefs to this function
        xrefs = [x.frm for x in idautils.XrefsTo(dec_func_ea,ida_xref.XREF_FAR)]
        # Filter xrefs by only at .text section (avoid .pdata, .rdata, etc)
        xrefs = [x for x in xrefs if idc.get_segm_name(x) == ".text"]

        # One of the xrefs is caller of string decryptor function
        caller_dec_func_ea = None
        for x in xrefs:
            # Find caller

            # .text:0000000140001A7C                         str_dec_caller      proc near               ; CODE XREF: sub_1400026D8+4E↓p
            # .text:0000000140001A7C 40 53                                   push    rbx
            # .text:0000000140001A7E 48 83 EC 20                             sub     rsp, 20h
            # .text:0000000140001A82 48 8B D9                                mov     rbx, rcx
            # .text:0000000140001A85 48 8B CA                                mov     rcx, rdx
            # .text:0000000140001A88 E8 DB FE FF FF                          call    str_dec
            caller = ida_funcs.get_func(x)
            
            # Go up 5 instructions and if any of instructions is "lea rcx,pStr" pass that function
            p = x
            okay_func = True
            for _ in range(4):
                if idc.print_insn_mnem(p) == "lea" and idc.print_operand(p,0) == "rcx":
                    # print(f"Found bad caller of string decryptor function at {hex(p)}")
                    okay_func = False
                    break
                p = idc.prev_head(p)

            if p == caller.start_ea and okay_func:
                print(f"Found caller of string decryptor function at {hex(p)}")
                caller_dec_func_ea = p
                first_xrefs = [k for k in xrefs if x != k]
                break
        else:
            raise ValueError("Caller of string decryptor function not found")
        # Find xrefs to caller of string decryptor function
        second_xrefs = [x.frm for x in idautils.XrefsTo(caller_dec_func_ea,ida_xref.XREF_FAR)]
        second_xrefs = [x for x in second_xrefs if idc.get_segm_name(x) == ".text"] 

        print(f"len f xrefs: {len(first_xrefs)}")
        print(f"len s xrefs: {len(second_xrefs)}")
        return first_xrefs,second_xrefs


    def find_strings_to_decrypt(self):
        first_xrefs,second_xrefs = self.find_func_xrefs_for_decryption()

        for f in first_xrefs:
            # Go up maximum 5 instructions to find "lea rcx,pStr"
            p = f
            pStr = None
            for _ in range(5):
                if idc.print_insn_mnem(p) == "lea" and idc.print_operand(p,0) == "rcx":
                    if idc.get_operand_type(p,1) != 2:
                        print(f"Bad address at {hex(p)}")
                        p = idc.prev_head(p)
                        continue
                    pStr = idc.get_operand_value(p,1)
                    break
                p = idc.prev_head(p)
            if pStr is None:
                print(f"Failed to find First xref at {hex(f)}")
                continue
                raise ValueError("pStr not found")
            # Read bytes from pStr until null byte
            s = b""
            while True:
                b = ida_bytes.get_bytes(pStr,1)
                if b == b"\x00":
                    break
                s += b
                pStr += 1
            dec = self.decrypt_str(s)
            if dec:
                print(f"first xref String at {hex(f)}: {dec}  {s.hex()}")
                self.add_cmt(f,dec)

        for f in second_xrefs:
            p = f
            pStr = None
            for _ in range(8):
                if (idc.print_insn_mnem(p) == "lea" or idc.print_insn_mnem(p) == "mov") and idc.print_operand(p,0) == "rdx":
                    if idc.get_operand_type(p,1) != 2:
                        print(f"Bad address at {hex(p)}")
                        p = idc.prev_head(p)
                        continue
                    pStr = idc.get_operand_value(p,1)
                    break
                p = idc.prev_head(p)
            if pStr is None:
                print(f"Failed to find Second xref at {hex(f)}")
                continue
                raise ValueError("pStr not found")
            # Read bytes from pStr until null byte
            s = b""
            while True:
                b = ida_bytes.get_bytes(pStr,1)
                if b == b"\x00":
                    break
                s += b
                pStr += 1
            dec = self.decrypt_str(s)
            if dec:
                print(f"Second xref String at {hex(f)}: {dec}  {s.hex()}")
                self.add_cmt(f,dec)
    
    def walk_possible_enc_str(self,start_ea):
        pStr = start_ea
        while True:
            string_start_ea = pStr
            s = b""
            while True:
                b = ida_bytes.get_bytes(pStr,1)
                if b[0] > 128:
                    return
                if b == b"\x00":
                    break
                s += b
                pStr += 1
            while True:
                b = ida_bytes.get_bytes(pStr,1)
                if b != b"\x00":
                    break
                pStr += 1

            dec = self.decrypt_str(s)
            print(f"{hex(string_start_ea)}: {dec}")



s = StrDecryptor()
s.find_strings_to_decrypt()




